<?php
declare(strict_types=1);
namespace App\Models;

use RuntimeException;

/**
 * ZogGpt - Lightweight view engine + hybrid static cache (no eval)
 *
 * Usage examples:
 *
 *   ZogGpt::setDir(__DIR__ . '/../Views');
 *   ZogGpt::setStaticDir(__DIR__ . '/../../storage/zog_static');
 *   ZogGpt::setCompiledDir(__DIR__ . '/../../storage/zog_compiled');
 *
 *   // Simple render with parameters
 *   echo ZogGpt::render('productView.php', [
 *       'page_title' => 'Products',
 *       'heading'    => 'Active products',
 *       'products'   => $products,
 *   ]);
 *
 *   // Hybrid example
 *   $postLink = 'my-post-link';
 *   $view = ZogGpt::hybrid('postsView.php', $postLink);
 *
 *   if ($view === false) {
 *       $posts = Post::latest()->get();
 *       echo ZogGpt::hybrid(
 *           'postsView.php',
 *           $postLink,
 *           ['posts' => $posts],
 *           ZogGpt::CACH_A_WEEK
 *       );
 *   } else {
 *       echo $view;
 *   }
 *
 * Template features (inside your .php view files):
 *
 *   - @{{ title }}                     // prints escaped PHP variable $title
 *   - @raw(htmlVar)                    // prints raw, unescaped HTML
 *   - @php( foreach ($products as $p) ) ... @php(endforeach)   // raw php
 *   - @json(products)                  // json_encode($products) for JS
 *   - @tojs(products)                  // same as @json (alias)
 *
 *   - <div zp-for="product, key of $products"> ... </div>
 *       => foreach ($products as $key => $product) { ... }
 *
 *   - <div zp-if="$product['is_free'] === true"> ... </div>
 *     <div zp-else-if="$product['is_free'] === 'today'"> ... </div>
 *     <div zp-else> ... </div>
 *
 * IMPORTANT:
 *   - Expressions in zp-if / zp-else-if MUST be valid PHP.
 *   - View files are compiled to PHP once and reused. No eval is used.
 *   - hybrid() writes a static HTML/PHP file with an expiration comment, e.g.:
 *       <!-- Automatically generated by zog: [ex:2025-11-25] -->
 */

class ZogException extends RuntimeException
{
}
class ZogTemplateException extends ZogException
{
}

class Zog
{
    /**
     * Base directory for view files.
     * Relative paths are resolved from the current working directory.
     */
    protected static string $viewDir = 'views';

    /**
     * Base directory for static / cached rendered pages (hybrid).
     */
    protected static string $staticDir = 'static';

    /**
     * Base directory for compiled PHP templates.
     */
    protected static string $compiledDir = 'storage/zog_compiled';

    /**
     * Default hybrid cache TTL in seconds (one week).
     */
    protected static ?int $defaultHybridCacheTtl = 604800;

    /**
     * Whether @php(...) directive is allowed.
     * If set to false, any use of @php will throw an exception.
     */
    protected static bool $allowRawPhpDirective = true;

    /**
     * Regex to detect the autogenerated cache comment in static files.
     */
    protected const CACHE_COMMENT_PATTERN =
        '/<!--\s*Automatically generated by zog:\s*\[ex:([0-9]{4}-[0-9]{2}-[0-9]{2})\]\s*-->/i';

    // Cache duration constants
    public const CACHE_NONE = 0;
    public const CACHE_A_MINUTE = 60;
    public const CACHE_AN_HOUR = 3600;
    public const CACHE_A_DAY = 86400;
    public const CACHE_A_WEEK = 604800;

    // Alias kept intentionally for compatibility with your sample code
    public const CACH_A_WEEK = 604800;

    /**
     * Configure the base directory for views.
     */
    public static function setDir(string $dir): void
    {
        $dir = rtrim($dir, "/\\");
        if ($dir === '') {
            throw new ZogException('View directory cannot be empty.');
        }
        self::$viewDir = $dir;
    }

    /**
     * Configure the base directory for static / cached files.
     */
    public static function setStaticDir(string $dir): void
    {
        $dir = rtrim($dir, "/\\");
        if ($dir === '') {
            throw new ZogException('Static directory cannot be empty.');
        }
        self::$staticDir = $dir;
    }

    /**
     * Configure the base directory for compiled templates.
     */
    public static function setCompiledDir(string $dir): void
    {
        $dir = rtrim($dir, "/\\");
        if ($dir === '') {
            throw new ZogException('Compiled directory cannot be empty.');
        }
        self::$compiledDir = $dir;
    }

    /**
     * Optionally override the default hybrid cache TTL (in seconds).
     * Pass null to disable default TTL and force explicit TTL in hybrid().
     */
    public static function setDefaultHybridCacheTtl(?int $seconds): void
    {
        if ($seconds !== null && $seconds < 0) {
            throw new ZogException('Default cache TTL cannot be negative.');
        }
        self::$defaultHybridCacheTtl = $seconds;
    }

    /**
     * Enable / disable @php(...) directive.
     */
    public static function allowRawPhpDirective(bool $allow): void
    {
        self::$allowRawPhpDirective = $allow;
    }

    /**
     * Magic handler so you can call ZogGpt::static('file') conveniently.
     *
     * NOTE:
     *   Recommended direct method is ZogGpt::staticFile('path/to/file.ext').
     */
    public static function __callStatic(string $name, array $arguments)
    {
        if ($name === 'static') {
            if (count($arguments) !== 1) {
                throw new ZogException('ZogGpt::static() expects exactly 1 argument (relative static file path).');
            }
            return self::staticFile((string) $arguments[0]);
        }

        throw new ZogException("Undefined static method ZogGpt::{$name}().");
    }

    /**
     * Read a static file from the static directory and return its raw contents.
     * No parsing or processing is performed.
     */
    public static function staticFile(string $relativePath): string
    {
        $relativePath = ltrim($relativePath, "/\\");
        $baseDir = self::getStaticDir();
        $fullPath = $baseDir . DIRECTORY_SEPARATOR . $relativePath;

        $realBase = realpath($baseDir);
        $realFile = realpath($fullPath);

        // Prevent directory traversal
        if ($realBase !== false && $realFile !== false && strpos($realFile, $realBase) !== 0) {
            throw new ZogException('Invalid static file path (path traversal not allowed).');
        }

        if (!is_file($fullPath)) {
            throw new ZogException("Static file not found: {$fullPath}");
        }

        $content = @file_get_contents($fullPath);
        if ($content === false) {
            throw new ZogException("Unable to read static file: {$fullPath}");
        }

        return $content;
    }

    /**
     * Render a view file using ZogGpt template engine.
     *
     * @param string $view  Relative view path (e.g., 'productView.php')
     * @param array  $data  Variables to make available in the view
     *
     * @return string Rendered HTML
     */
    public static function render(string $view, array $data = []): string
    {
        $viewPath = self::resolveViewPath($view);
        $compiledPath = self::compileViewIfNeeded($viewPath);

        return self::evaluateCompiledFile($compiledPath, $data);
    }

    /**
     * Hybrid rendering with optional lazy data factory.
     *
     * Usage modes:
     *
     * 1) Read-only (no data):
     *      $html = Zog::hybrid('view.php', $key);
     *      // returns string (valid cached content) or false (missing/expired)
     *
     * 2) Explicit data (always re-render & overwrite cache):
     *      $html = Zog::hybrid('view.php', $key, ['title' => 'Hello'], Zog::CACHE_A_DAY);
     *
     * 3) Lazy data factory (callable):
     *      $html = Zog::hybrid('view.php', $key, function () {
     *          // heavy DB calls...
     *          return ['title' => 'Hello'];
     *      }, Zog::CACHE_A_DAY);
     *      // factory is called ONLY if cache is missing or expired.
     */
    public static function hybrid(
        string $view,
        string|array $key,
        array|callable|null $dataOrFactory = null,
        ?int $cacheTtl = null
    ) {
        $staticPath = self::getHybridStaticPath($view, $key);

        $hasStatic = is_file($staticPath);
        $content = null;

        if ($hasStatic) {
            $content = @file_get_contents($staticPath);
            if ($content === false) {
                // Treat unreadable file as non-existent
                $hasStatic = false;
                $content = null;
            }
        }

        // -------------------------------------------------
        // 1) Read-only mode: just try to use existing cache.
        // -------------------------------------------------
        if ($dataOrFactory === null) {
            if (!$hasStatic || $content === null) {
                return false;
            }

            $expiry = self::parseCacheExpiryFromStatic($content);
            if ($expiry === null) {
                // No valid expiry => treat as expired
                return false;
            }

            $today = new \DateTimeImmutable('now');
            if ($today->format('Y-m-d') <= $expiry->format('Y-m-d')) {
                // Still valid
                return $content;
            }

            // Expired
            return false;
        }

        // -------------------------------------------------
        // 2) Direct data array: always re-render & overwrite.
        //    This keeps behaviour compatible with older version.
        // -------------------------------------------------
        if (is_array($dataOrFactory)) {
            if ($cacheTtl === null) {
                $cacheTtl = self::$defaultHybridCacheTtl ?? 0;
            }

            return self::renderAndStoreHybrid($view, $dataOrFactory, $staticPath, $cacheTtl);
        }

        // -------------------------------------------------
        // 3) Lazy factory: called ONLY on miss / expired.
        // -------------------------------------------------
        if (is_callable($dataOrFactory)) {
            // If we already have a valid, non-expired static file,
            // return it and DO NOT call the factory.
            if ($hasStatic && $content !== null) {
                $expiry = self::parseCacheExpiryFromStatic($content);
                if ($expiry !== null) {
                    $today = new \DateTimeImmutable('now');
                    if ($today->format('Y-m-d') <= $expiry->format('Y-m-d')) {
                        return $content;
                    }
                }
            }

            // Missing or expired cache => compute data lazily.
            $data = $dataOrFactory();

            if (!is_array($data)) {
                throw new ZogException('Hybrid data factory must return an array.');
            }

            if ($cacheTtl === null) {
                $cacheTtl = self::$defaultHybridCacheTtl ?? 0;
            }

            return self::renderAndStoreHybrid($view, $data, $staticPath, $cacheTtl);
        }

        throw new ZogException(
            'Hybrid third parameter must be either an array, a callable, or null.'
        );
    }



    /**
     * Remove all static files in the configured static directory.
     * This does NOT remove the directory itself.
     */
    public static function clearStatics(): void
    {
        $dir = self::getStaticDir();
        if (!is_dir($dir)) {
            return;
        }

        $iterator = new \DirectoryIterator($dir);
        foreach ($iterator as $fileInfo) {
            if ($fileInfo->isDot()) {
                continue;
            }
            if ($fileInfo->isFile()) {
                @unlink($fileInfo->getPathname());
            }
        }
    }

    /**
     * Remove all compiled template files.
     * This does NOT remove the directory itself.
     */
    public static function clearCompiled(): void
    {
        $dir = self::getCompiledDir();
        if (!is_dir($dir)) {
            return;
        }

        $iterator = new \DirectoryIterator($dir);
        foreach ($iterator as $fileInfo) {
            if ($fileInfo->isDot()) {
                continue;
            }
            if ($fileInfo->isFile()) {
                @unlink($fileInfo->getPathname());
            }
        }
    }

    /* ============================================================
     * Internal helpers: directories & paths
     * ============================================================
     */

    /**
     * Resolve the absolute path to a view file.
     */
    protected static function resolveViewPath(string $view): string
    {
        $view = ltrim($view, "/\\");
        $dir = self::getViewDir();
        $fullDir = $dir . DIRECTORY_SEPARATOR . $view;

        if (!is_file($fullDir)) {
            throw new ZogException("View file does not exist: {$fullDir}");
        }

        return $fullDir;
    }

    /**
     * Get and validate the view directory.
     */
    protected static function getViewDir(): string
    {
        $dir = self::$viewDir;
        if ($dir === '') {
            throw new ZogException('View directory is not configured.');
        }
        if (!is_dir($dir)) {
            throw new ZogException("View directory does not exist: {$dir}");
        }
        return $dir;
    }

    /**
     * Get (and lazily create) the static directory.
     */
    protected static function getStaticDir(): string
    {
        $dir = self::$staticDir;
        if ($dir === '') {
            throw new ZogException('Static directory is not configured.');
        }
        if (!is_dir($dir)) {
            if (!@mkdir($dir, 0775, true) && !is_dir($dir)) {
                throw new ZogException("Unable to create static directory: {$dir}");
            }
        }
        return $dir;
    }

    /**
     * Get (and lazily create) the compiled templates directory.
     */
    protected static function getCompiledDir(): string
    {
        $dir = self::$compiledDir;
        if ($dir === '') {
            throw new ZogException('Compiled directory is not configured.');
        }
        if (!is_dir($dir)) {
            if (!@mkdir($dir, 0775, true) && !is_dir($dir)) {
                throw new ZogException("Unable to create compiled directory: {$dir}");
            }
        }
        return $dir;
    }

    /**
     * Build the static filename used by hybrid() for a given view + key.
     *
     * Example:
     *   view: "postsView.php"
     *   key:  "my-post-link"
     *   =>   "{staticDir}/postsView-my-post-link.php"
     */
    /**
     * Build the static filename used by hybrid() for a given view + key.
     *
     * Examples:
     *   view: "postsView.php", key: "my-post-link"
     *       => "{staticDir}/postsView-my-post-link.php"
     *
     *   view: "postsView.php", key: ['slug' => 'my-post-link', 'lang' => 'fa', 'device' => 'm']
     *       => "{staticDir}/postsView-h-e4f1c2a3b7c9d812.php"
     */
    protected static function getHybridStaticPath(string $view, string|array $key): string
    {
        $baseDir = self::getStaticDir();
        $viewBase = pathinfo($view, PATHINFO_FILENAME);

        if (is_array($key)) {
            // Normalize array key so that the same logical key always produces the same hash
            $normalized = self::normalizeHybridKeyArray($key);

            $json = json_encode($normalized, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
            if ($json === false) {
                throw new ZogException('Unable to JSON-encode hybrid cache key.');
            }

            // Short hash for filename
            $hash = substr(sha1($json), 0, 16);
            $safeKey = 'h-' . $hash;
        } else {
            // string key: keep human-readable slug-like behaviour
            $safeKey = preg_replace('/[^A-Za-z0-9_\-]+/', '-', $key);
            $safeKey = trim($safeKey, '-_');
            if ($safeKey === '') {
                $safeKey = 'default';
            }
        }

        $fileName = $viewBase . '-' . $safeKey . '.php';

        return $baseDir . DIRECTORY_SEPARATOR . $fileName;
    }

    /**
     * Normalize an array key into a stable structure for hashing.
     *
     * - Associative arrays are ksort()'ed by key so that order does not matter.
     * - Numeric-indexed arrays keep their order, because order usually carries meaning.
     * - Nested arrays are normalized recursively.
     */
    protected static function normalizeHybridKeyArray(array $key): array
    {
        // Detect if the array is associative (or mixed)
        $isAssoc = array_keys($key) !== range(0, count($key) - 1);
        if ($isAssoc) {
            ksort($key);
        }

        $normalized = [];
        foreach ($key as $k => $v) {
            if (is_array($v)) {
                $normalized[$k] = self::normalizeHybridKeyArray($v);
            } else {
                $normalized[$k] = $v;
            }
        }

        return $normalized;
    }


    /**
     * Compile a view file into a cached PHP file if needed,
     * and return the compiled file path.
     */
    protected static function compileViewIfNeeded(string $viewPath): string
    {
        $compiledDir = self::getCompiledDir();
        $hash = sha1($viewPath);
        $compiledPath = $compiledDir . DIRECTORY_SEPARATOR . $hash . '.php';

        $needsCompile = true;

        if (is_file($compiledPath)) {
            $viewMtime = filemtime($viewPath) ?: 0;
            $compiledMtime = filemtime($compiledPath) ?: 0;

            // Recompile only if view is newer than compiled file
            if ($compiledMtime >= $viewMtime) {
                $needsCompile = false;
            }
        }

        if ($needsCompile) {
            $template = @file_get_contents($viewPath);
            if ($template === false) {
                throw new ZogException("Unable to read view file: {$viewPath}");
            }

            $compiledBody = self::compileTemplate($template);

            $header = "<?php\n"
                . "/* Compiled by ZogGpt from: {$viewPath} at " . date('c') . " */\n"
                . "?>\n";

            $compiledPhp = $header . $compiledBody;

            if (@file_put_contents($compiledPath, $compiledPhp, LOCK_EX) === false) {
                throw new ZogException("Unable to write compiled template: {$compiledPath}");
            }
        }

        return $compiledPath;
    }

    /**
     * Render view and store static version with expiration comment.
     */
    protected static function renderAndStoreHybrid(
        string $view,
        array $data,
        string $staticPath,
        int $ttlSeconds
    ): string {
        $output = self::render($view, $data);

        // Compute expiration date; if ttl <= 0, treat as "never expires"
        if ($ttlSeconds > 0) {
            $expiry = (new \DateTimeImmutable('now'))
                ->add(new \DateInterval('PT' . $ttlSeconds . 'S'));
            $expiryDateStr = $expiry->format('Y-m-d');
        } else {
            $expiryDateStr = '9999-12-31';
        }

        $comment = '<!-- Automatically generated by zog: [ex:' . $expiryDateStr . '] -->';

        $contentToWrite = $comment . "\n" . $output;

        $dir = dirname($staticPath);
        if (!is_dir($dir)) {
            if (!@mkdir($dir, 0775, true) && !is_dir($dir)) {
                throw new ZogException('Unable to create directory for static file: ' . $dir);
            }
        }

        if (@file_put_contents($staticPath, $contentToWrite, LOCK_EX) === false) {
            throw new ZogException('Failed to write static cache file: ' . $staticPath);
        }

        return $contentToWrite;
    }

    /**
     * Parse expiration date from a static file's autogenerated comment.
     */
    protected static function parseCacheExpiryFromStatic(string $content): ?\DateTimeImmutable
    {
        if (!preg_match(self::CACHE_COMMENT_PATTERN, $content, $matches)) {
            return null;
        }

        $dateStr = $matches[1] ?? '';
        if ($dateStr === '') {
            return null;
        }

        $dt = \DateTimeImmutable::createFromFormat('Y-m-d', $dateStr);
        if ($dt === false) {
            return null;
        }

        return $dt;
    }

    /* ============================================================
     * Template compilation (DOM → PHP)
     * ============================================================
     */

    /**
     * Compile the raw template string into executable PHP+HTML string.
     *
     * - Parses HTML using DOMDocument.
     * - Handles:
     *     @{{ expr }}         => escaped echo
     *     @raw(expr)          => raw echo
     *     @php( code )        => raw PHP code
     *     @json(expr) / @tojs(expr) => json_encode(...)
     *     zp-for="a, i of $arr"
     *     zp-if / zp-else-if / zp-else
     */
    protected static function compileTemplate(string $template): string
    {
        $dom = new \DOMDocument('1.0', 'UTF-8');

        $previous = libxml_use_internal_errors(true);
        $flags = LIBXML_HTML_NOIMPLIED | LIBXML_HTML_NODEFDTD;

        $dom->loadHTML($template, $flags);
        libxml_clear_errors();
        libxml_use_internal_errors($previous);

        return self::compileNodeList($dom->childNodes);
    }

    /**
     * Recursively compile a DOMNodeList into PHP/HTML string.
     */
    protected static function compileNodeList(\DOMNodeList $nodes): string
    {
        $buffer = '';

        // Convert NodeList to simple array for easier indexing
        $array = [];
        foreach ($nodes as $node) {
            $array[] = $node;
        }

        $len = count($array);
        for ($i = 0; $i < $len; $i++) {
            $node = $array[$i];

            if ($node instanceof \DOMText) {
                $buffer .= self::compileText($node->wholeText);
            } elseif ($node instanceof \DOMElement) {
                // Handle zp-if chains (if / else-if / else)
                if ($node->hasAttribute('zp-if')) {
                    $buffer .= self::compileIfChain($array, $i, $len);
                } elseif ($node->hasAttribute('zp-else-if') || $node->hasAttribute('zp-else')) {
                    // If you reach here, there was no preceding zp-if in this level
                    throw new ZogTemplateException(
                        'Found zp-else-if / zp-else without a preceding zp-if near <' . $node->tagName . '>.'
                    );
                } else {
                    $buffer .= self::compileElement($node);
                }
            } elseif ($node instanceof \DOMComment) {
                $buffer .= '<!--' . $node->nodeValue . '-->';
            } else {
                // Ignore other node types
            }
        }

        return $buffer;
    }

    /**
     * Compile a zp-if / zp-else-if / zp-else chain starting at index $i.
     * Updates $i to the last index of the chain.
     */
    protected static function compileIfChain(array $nodes, int &$i, int $len): string
    {
        $branches = [];

        $first = $nodes[$i];
        if (!($first instanceof \DOMElement)) {
            throw new ZogTemplateException('Internal error: zp-if chain must start with an element node.');
        }

        $expr = trim($first->getAttribute('zp-if'));
        $first->removeAttribute('zp-if');

        $branches[] = [
            'type' => 'if',
            'expr' => $expr,
            'node' => $first,
        ];

        $j = $i + 1;
        while ($j < $len) {
            $sib = $nodes[$j];

            // Skip pure whitespace text nodes between branches
            if ($sib instanceof \DOMText) {
                if (trim($sib->wholeText) === '') {
                    // Just indentation / newlines – ignore for chain detection
                    $j++;
                    continue;
                }
                // Non-empty text breaks the chain
                break;
            }

            // Skip comments between branches
            if ($sib instanceof \DOMComment) {
                $j++;
                continue;
            }

            // Any other non-element node breaks the chain
            if (!($sib instanceof \DOMElement)) {
                break;
            }

            if ($sib->hasAttribute('zp-else-if')) {
                $expr2 = trim($sib->getAttribute('zp-else-if'));
                $sib->removeAttribute('zp-else-if');

                $branches[] = [
                    'type' => 'elseif',
                    'expr' => $expr2,
                    'node' => $sib,
                ];

                $j++;
                continue;
            }

            if ($sib->hasAttribute('zp-else')) {
                $sib->removeAttribute('zp-else');

                $branches[] = [
                    'type' => 'else',
                    'expr' => null,
                    'node' => $sib,
                ];

                $j++;
                break; // else must be last
            }

            // A normal element (without zp-else-if/zp-else) means the chain ended
            break;
        }

        $out = '';
        foreach ($branches as $branch) {
            if ($branch['type'] === 'if') {
                $out .= '<?php if (' . self::ensurePhpExpression($branch['expr']) . '): ?>';
            } elseif ($branch['type'] === 'elseif') {
                $out .= '<?php elseif (' . self::ensurePhpExpression($branch['expr']) . '): ?>';
            } else { // else
                $out .= '<?php else: ?>';
            }

            $out .= self::compileElement($branch['node']);
        }

        $out .= '<?php endif; ?>';

        // Move external loop index to end of chain
        $i = $j - 1;

        return $out;
    }

    /**
     * Compile a single HTML element (plus its children) into PHP/HTML.
     * Handles zp-for at element level.
     */
    protected static function compileElement(\DOMElement $el): string
    {
        $tag = $el->tagName;

        // Attributes except zp-*
        $attrParts = [];
        if ($el->hasAttributes()) {
            foreach ($el->attributes as $attr) {
                $name = $attr->nodeName;
                if (strpos($name, 'zp-') === 0) {
                    // zp-* attributes are consumed by the template engine and
                    // should not appear in the final HTML output.
                    continue;
                }
                $value = $attr->nodeValue ?? '';
                $attrParts[] = $name . '="' . htmlspecialchars($value, ENT_QUOTES | ENT_SUBSTITUTE, 'UTF-8') . '"';
            }
        }

        $attrString = $attrParts ? ' ' . implode(' ', $attrParts) : '';

        // Self-closing tags that should not have closing tag in HTML
        $selfClosingTags = [
            'area',
            'base',
            'br',
            'col',
            'embed',
            'hr',
            'img',
            'input',
            'link',
            'meta',
            'param',
            'source',
            'track',
            'wbr',
        ];
        $isSelfClosing = in_array(strtolower($tag), $selfClosingTags, true);

        $inner = '';
        if (!$isSelfClosing) {
            $inner = self::compileNodeList($el->childNodes);
        }

        $openTag = '<' . $tag . $attrString . ($isSelfClosing ? ' />' : '>');
        $closeTag = $isSelfClosing ? '' : '</' . $tag . '>';

        // Handle zp-for (loop)
        $zpForExpr = null;
        if ($el->hasAttribute('zp-for')) {
            $zpForExpr = trim($el->getAttribute('zp-for'));
            $el->removeAttribute('zp-for');
        }

        if ($zpForExpr !== null && $zpForExpr !== '') {
            [$collectionExpr, $itemVar, $keyVar] = self::parseForExpression($zpForExpr);

            $loopPhp = '<?php foreach (' . $collectionExpr . ' as '
                . ($keyVar ? $keyVar . ' => ' : '')
                . $itemVar . '): ?>';
            $endLoop = '<?php endforeach; ?>';

            return $loopPhp . $openTag . $inner . $closeTag . $endLoop;
        }

        return $openTag . $inner . $closeTag;
    }

    /**
     * Compile plain text node content:
     *   - @php( code )              => <?php code ?>
     *   - @json(expr) / @tojs(expr) => <?php echo json_encode(expr, ...) ?>
     *   - @raw(expr)                => <?php echo expr; ?>
     *   - @{{ expr }}               => escaped echo
     */
    protected static function compileText(string $text): string
    {
        if ($text === '') {
            return '';
        }

        // Enforce raw PHP directive policy
        if (!self::$allowRawPhpDirective && strpos($text, '@php(') !== false) {
            throw new ZogTemplateException('@php directive is disabled for security reasons.');
        }

        // 1) Handle @php(...) with balanced parentheses
        if (self::$allowRawPhpDirective) {
            $text = self::replaceDirectiveWithBalancedParentheses(
                $text,
                '@php(',
                function (string $inner): string {
                    $code = trim($inner);
                    if ($code === '') {
                        throw new ZogTemplateException('@php() requires non-empty code.');
                    }
                    return '<?php ' . $code . ' ?>';
                }
            );
        }

        // 2) Handle @json(...)  (main directive)
        $text = self::replaceDirectiveWithBalancedParentheses(
            $text,
            '@json(',
            function (string $inner): string {
                return self::buildJsonDirective($inner);
            }
        );

        // 3) Handle @tojs(...) (alias of @json)
        $text = self::replaceDirectiveWithBalancedParentheses(
            $text,
            '@tojs(',
            function (string $inner): string {
                return self::buildJsonDirective($inner);
            }
        );

        // 4) Handle @raw(expr)
        $text = self::replaceDirectiveWithBalancedParentheses(
            $text,
            '@raw(',
            function (string $inner): string {
                $expr = trim($inner);
                if ($expr === '') {
                    throw new ZogTemplateException('@raw() requires a non-empty expression.');
                }
                if (preg_match('/^[A-Za-z_][A-Za-z0-9_]*$/', $expr) && $expr[0] !== '$') {
                    $expr = '$' . $expr;
                }
                return '<?php echo ' . $expr . '; ?>';
            }
        );

        // 5) Handle @{{ expr }}  (escaped echo)
        $text = preg_replace_callback(
            '/@\{\{\s*(.+?)\s*\}\}/s',
            function (array $m): string {
                $expr = trim($m[1]);
                if ($expr === '') {
                    return '';
                }

                // If expr is a bare identifier, auto-prefix with $
                if (preg_match('/^[A-Za-z_][A-Za-z0-9_]*$/', $expr) && $expr[0] !== '$') {
                    $expr = '$' . $expr;
                }

                return '<?php echo htmlspecialchars(' . $expr . ", ENT_QUOTES, 'UTF-8'); ?>";
            },
            $text
        );

        return $text;
    }

    /**
     * Balanced parentheses replacement for directives like:
     *   @php(...)
     *   @json(...)
     *   @tojs(...)
     *   @raw(...)
     *
     * @param string   $text      Original text
     * @param string   $token     Directive prefix, e.g. "@php(" or "@json("
     * @param callable $transform function(string $inner): string  -> returns replacement
     *
     * @return string
     */
    protected static function replaceDirectiveWithBalancedParentheses(
        string $text,
        string $token,
        callable $transform
    ): string {
        $tokenLen = strlen($token);
        $offset = 0;

        while (true) {
            $start = strpos($text, $token, $offset);
            if ($start === false) {
                break;
            }

            $openParenPos = $start + $tokenLen - 1; // position of '('
            $len = strlen($text);

            if ($openParenPos >= $len || $text[$openParenPos] !== '(') {
                throw new ZogTemplateException("Internal error parsing directive {$token}");
            }

            $depth = 1;
            $i = $openParenPos + 1;

            for (; $i < $len; $i++) {
                $ch = $text[$i];

                if ($ch === '(') {
                    $depth++;
                } elseif ($ch === ')') {
                    $depth--;
                    if ($depth === 0) {
                        break;
                    }
                }
            }

            if ($depth !== 0 || $i >= $len) {
                throw new ZogTemplateException("Unmatched parentheses in {$token} directive.");
            }

            // Inner contents between the outermost (...)
            $inner = substr($text, $openParenPos + 1, $i - ($openParenPos + 1));

            $replacement = $transform($inner);

            // Replace the whole @xxx( ... ) block
            $text = substr($text, 0, $start)
                . $replacement
                . substr($text, $i + 1);

            // Continue searching after the replacement
            $offset = $start + strlen($replacement);
        }

        return $text;
    }

    /**
     * Build json_encode(...) directive used by @json and @tojs.
     */
    protected static function buildJsonDirective(string $inner): string
    {
        $expr = trim($inner);
        if ($expr === '') {
            throw new ZogTemplateException('@json() / @tojs() requires a non-empty expression.');
        }

        // If expr is a bare identifier (like "products"), auto-prefix with $
        if (preg_match('/^[A-Za-z_][A-Za-z0-9_]*$/', $expr) && $expr[0] !== '$') {
            $expr = '$' . $expr;
        }

        return '<?php echo json_encode(' . $expr
            . ', JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES); ?>';
    }

    /**
     * Parse zp-for expression, e.g.:
     *   "product of $products"
     *   "product, key of $products"
     *
     * Returns array [collectionExpr, $itemVar, $keyVarOrNull].
     */
    protected static function parseForExpression(string $expr): array
    {
        $expr = trim($expr);
        if ($expr === '') {
            throw new ZogTemplateException('Empty zp-for expression.');
        }

        // pattern: item, key of collection   (with optional '$' on item/key)
        if (
            preg_match(
                '/^\$?([A-Za-z_][A-Za-z0-9_]*)\s*,\s*\$?([A-Za-z_][A-Za-z0-9_]*)\s+of\s+(.+)$/',
                $expr,
                $m
            )
        ) {
            $itemVar = self::ensurePhpVariable($m[1]); // خودش $ اضافه می‌کند
            $keyVar = self::ensurePhpVariable($m[2]);
            $collectionExpr = self::ensurePhpExpression($m[3]);

            return [$collectionExpr, $itemVar, $keyVar];
        }

        // pattern: item of collection (with optional '$' on item)
        if (
            preg_match(
                '/^\$?([A-Za-z_][A-Za-z0-9_]*)\s+of\s+(.+)$/',
                $expr,
                $m
            )
        ) {
            $itemVar = self::ensurePhpVariable($m[1]);
            $collectionExpr = self::ensurePhpExpression($m[2]);

            return [$collectionExpr, $itemVar, null];
        }

        throw new ZogTemplateException('Invalid zp-for expression: ' . $expr);
    }


    /**
     * Ensure a variable name is prefixed with '$'.
     */
    protected static function ensurePhpVariable(string $name): string
    {
        $name = trim($name);
        if ($name === '') {
            throw new ZogTemplateException('Empty variable name in zp-for expression.');
        }

        if ($name[0] !== '$') {
            $name = '$' . $name;
        }

        return $name;
    }

    /**
     * Ensure a PHP expression is non-empty.
     * (You are responsible for making it syntactically valid PHP.)
     */
    protected static function ensurePhpExpression(string $expr): string
    {
        $expr = trim($expr);
        if ($expr === '') {
            throw new ZogTemplateException('Empty PHP expression in template.');
        }
        return $expr;
    }

    /* ============================================================
     * Template evaluation (require compiled file)
     * ============================================================
     */

    /**
     * Evaluate a compiled template file with the given data (no eval).
     *
     * All keys in $data are extracted as variables.
     * Full array is also available as $zogData inside the template if needed.
     */
    protected static function evaluateCompiledFile(string $compiledPath, array $data): string
    {
        $zogData = $data;

        ob_start();
        try {
            (function () use ($compiledPath, $zogData) {
                if (!empty($zogData)) {
                    extract($zogData, EXTR_SKIP);
                }
                require $compiledPath;
            })();
        } catch (\Throwable $e) {
            ob_end_clean();
            throw new ZogException(
                'Error while rendering template: ' . $e->getMessage(),
                0,
                $e
            );
        }

        return (string) ob_get_clean();
    }
}
