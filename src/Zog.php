<?php
declare(strict_types=1);

namespace Zog;

/**
 * Zog - Lightweight view engine + hybrid static cache (no eval)
 *
 * This version delegates all template parsing/compilation to Parser::compile()
 * (no DOMDocument usage). It keeps the same public API as previous versions:
 *
 *  - Zog::render($view, $data = [])
 *  - Zog::renderLayout($layoutView, $view, $data = [])
 *  - Zog::component($view, $data = [])
 *  - Zog::hybrid($view, $key, $dataOrFactory = null, ?int $ttl = null)
 *  - Zog::staticFile($path)
 *  - Zog::clearStatics(), Zog::clearCompiled()
 *
 * It also supports:
 *  - Hybrid cache comment: <!-- Automatically generated by zog: [ex:YYYY-MM-DD] -->
 *  - Raw PHP directive policy via allowRawPhpDirective()/isRawPhpDirectiveAllowed()
 */

class ZogException extends \RuntimeException
{
}

class ZogTemplateException extends ZogException
{
}

class Zog
{
    /**
     * Base directory for view files.
     * Relative paths are resolved from the current working directory.
     */
    protected static string $viewDir = 'views';

    /**
     * Base directory for static / cached rendered pages (hybrid).
     */
    protected static string $staticDir = 'static';

    /**
     * Base directory for compiled PHP templates.
     */
    protected static string $compiledDir = 'storage/zog_compiled';

    /**
     * Default hybrid cache TTL in seconds (one week).
     */
    protected static ?int $defaultHybridCacheTtl = 604800;

    /**
     * Whether @php(...) directive is allowed.
     * If set to false, any use of @php will throw an exception in Parser.
     */
    protected static bool $allowRawPhpDirective = true;

    /**
     * Regex to detect the autogenerated cache comment in static files.
     */
    protected const CACHE_COMMENT_PATTERN =
        '/<!--\s*Automatically generated by zog:\s*\[ex:([0-9]{4}-[0-9]{2}-[0-9]{2})\]\s*-->/i';

    // Cache duration constants
    public const CACHE_NONE     = 0;
    public const CACHE_A_MINUTE = 60;
    public const CACHE_AN_HOUR  = 3600;
    public const CACHE_A_DAY    = 86400;
    public const CACHE_A_WEEK   = 604800;

    // Alias kept intentionally for compatibility with your sample code
    public const CACH_A_WEEK = 604800;

    /* ============================================================
     * Configuration
     * ============================================================
     */

    /**
     * Configure the base directory for views.
     */
    public static function setViewDir(string $dir): void
    {
        $dir = rtrim($dir, "/\\");
        if ($dir === '') {
            throw new ZogException('View directory cannot be empty.');
        }
        self::$viewDir = $dir;
    }

    /**
     * Configure the base directory for static / cached files.
     */
    public static function setStaticDir(string $dir): void
    {
        $dir = rtrim($dir, "/\\");
        if ($dir === '') {
            throw new ZogException('Static directory cannot be empty.');
        }
        self::$staticDir = $dir;
    }

    /**
     * Configure the base directory for compiled templates.
     */
    public static function setCompiledDir(string $dir): void
    {
        $dir = rtrim($dir, "/\\");
        if ($dir === '') {
            throw new ZogException('Compiled directory cannot be empty.');
        }
        self::$compiledDir = $dir;
    }

    /**
     * Optionally override the default hybrid cache TTL (in seconds).
     * Pass null to disable default TTL and force explicit TTL in hybrid().
     */
    public static function setDefaultHybridCacheTtl(?int $seconds): void
    {
        if ($seconds !== null && $seconds < 0) {
            throw new ZogException('Default cache TTL cannot be negative.');
        }
        self::$defaultHybridCacheTtl = $seconds;
    }

    /**
     * Enable / disable @php(...) directive.
     */
    public static function allowRawPhpDirective(bool $allow): void
    {
        self::$allowRawPhpDirective = $allow;
    }

    /**
     * Return current policy for @php(...) directive.
     * Used by Parser::compile().
     */
    public static function isRawPhpDirectiveAllowed(): bool
    {
        return self::$allowRawPhpDirective;
    }

    /* ============================================================
     * Public API
     * ============================================================
     */

    /**
     * Magic handler so you can call Zog::static('file') conveniently.
     *
     * NOTE:
     *   Recommended direct method is Zog::staticFile('path/to/file.ext').
     */
    public static function __callStatic(string $name, array $arguments)
    {
        if ($name === 'static') {
            if (count($arguments) !== 1) {
                throw new ZogException('Zog::static() expects exactly 1 argument (relative static file path).');
            }
            return self::staticFile((string) $arguments[0]);
        }

        throw new ZogException("Undefined static method Zog::{$name}().");
    }

    /**
     * Read a static file from the static directory and return its raw contents.
     * No parsing or processing is performed.
     */
    public static function staticFile(string $relativePath): string
    {
        $relativePath = ltrim($relativePath, "/\\");
        $baseDir      = self::getStaticDir();
        $fullPath     = $baseDir . DIRECTORY_SEPARATOR . $relativePath;

        $realBase = realpath($baseDir);
        $realFile = realpath($fullPath);

        // Prevent directory traversal
        if ($realBase !== false && $realFile !== false && strpos($realFile, $realBase) !== 0) {
            throw new ZogException('Invalid static file path (path traversal not allowed).');
        }

        if (!is_file($fullPath)) {
            throw new ZogException("Static file not found: {$fullPath}");
        }

        $content = @file_get_contents($fullPath);
        if ($content === false) {
            throw new ZogException("Unable to read static file: {$fullPath}");
        }

        return $content;
    }

    /**
     * Render a view file using Zog template engine.
     *
     * @param string $view  Relative view path (e.g., 'productView.php')
     * @param array  $data  Variables to make available in the view
     *
     * @return string Rendered HTML
     */
    public static function render(string $view, array $data = []): string
    {
        $viewPath     = self::resolveViewPath($view);
        $compiledPath = self::compileViewIfNeeded($viewPath);

        return self::evaluateCompiledFile($compiledPath, $data);
    }

    /**
     * Render a view inside a layout using the section / yield API.
     *
     * @param string $layoutView Layout view (e.g. 'layouts/main.php')
     * @param string $view       Child view (e.g. 'pages/home.php')
     * @param array  $data       Shared data for both views
     */
    public static function renderLayout(
        string $layoutView,
        string $view,
        array $data = []
    ): string {
        return View::renderWithLayout($view, $layoutView, $data);
    }

    /**
     * Render a view as a component / partial.
     *
     * Can be called directly from PHP or via @component(...) in templates.
     */
    public static function component(string $view, array $data = []): string
    {
        return View::component($view, $data);
    }

    /**
     * Hybrid rendering with optional lazy data factory.
     *
     * @param string               $view          View file to render
     * @param string|array         $key           Cache key (string or array)
     * @param array|callable|null  $dataOrFactory Data array, lazy factory, or null (read-only mode)
     * @param int|null             $cacheTtl      TTL in seconds (null => use default)
     *
     * @return string|false Rendered content or false in read-only mode when cache is missing/expired
     */
    public static function hybrid(
        string $view,
        string|array $key,
        array|callable|null $dataOrFactory = null,
        ?int $cacheTtl = null
    ) {
        $staticPath = self::getHybridStaticPath($view, $key);

        $hasStatic = is_file($staticPath);
        $content   = null;

        if ($hasStatic) {
            $content = @file_get_contents($staticPath);
            if ($content === false) {
                // Treat unreadable file as non-existent
                $hasStatic = false;
                $content   = null;
            }
        }

        // -------------------------------------------------
        // 1) Read-only mode: just try to use existing cache.
        // -------------------------------------------------
        if ($dataOrFactory === null) {
            if (!$hasStatic || $content === null) {
                return false;
            }

            $expiry = self::parseCacheExpiryFromStatic($content);
            if ($expiry === null) {
                // No valid expiry => treat as expired
                return false;
            }

            $today = new \DateTimeImmutable('now');
            if ($today->format('Y-m-d') <= $expiry->format('Y-m-d')) {
                // Still valid
                return $content;
            }

            // Expired
            return false;
        }

        // -------------------------------------------------
        // 2) Direct data array: always re-render & overwrite.
        //    This keeps behaviour compatible with older version.
        // -------------------------------------------------
        if (is_array($dataOrFactory)) {
            if ($cacheTtl === null) {
                $cacheTtl = self::$defaultHybridCacheTtl ?? 0;
            }

            return self::renderAndStoreHybrid($view, $dataOrFactory, $staticPath, $cacheTtl);
        }

        // -------------------------------------------------
        // 3) Lazy factory: called ONLY on miss / expired.
        // -------------------------------------------------
        if (is_callable($dataOrFactory)) {
            // If we already have a valid, non-expired static file,
            // return it and DO NOT call the factory.
            if ($hasStatic && $content !== null) {
                $expiry = self::parseCacheExpiryFromStatic($content);
                if ($expiry !== null) {
                    $today = new \DateTimeImmutable('now');
                    if ($today->format('Y-m-d') <= $expiry->format('Y-m-d')) {
                        return $content;
                    }
                }
            }

            // Missing or expired cache => compute data lazily.
            $data = $dataOrFactory();

            if (!is_array($data)) {
                throw new ZogException('Hybrid data factory must return an array.');
            }

            if ($cacheTtl === null) {
                $cacheTtl = self::$defaultHybridCacheTtl ?? 0;
            }

            return self::renderAndStoreHybrid($view, $data, $staticPath, $cacheTtl);
        }

        throw new ZogException(
            'Hybrid third parameter must be either an array, a callable, or null.'
        );
    }

    /**
     * Remove all static files in the configured static directory.
     * This does NOT remove the directory itself.
     */
    public static function clearStatics(): void
    {
        $dir = self::getStaticDir();
        if (!is_dir($dir)) {
            return;
        }

        $iterator = new \DirectoryIterator($dir);
        foreach ($iterator as $fileInfo) {
            if ($fileInfo->isDot()) {
                continue;
            }
            if ($fileInfo->isFile()) {
                @unlink($fileInfo->getPathname());
            }
        }
    }

    /**
     * Remove all compiled template files.
     * This does NOT remove the directory itself.
     */
    public static function clearCompiled(): void
    {
        $dir = self::getCompiledDir();
        if (!is_dir($dir)) {
            return;
        }

        $iterator = new \DirectoryIterator($dir);
        foreach ($iterator as $fileInfo) {
            if ($fileInfo->isDot()) {
                continue;
            }
            if ($fileInfo->isFile()) {
                @unlink($fileInfo->getPathname());
            }
        }
    }

    /* ============================================================
     * Internal helpers: directories & paths
     * ============================================================
     */

    /**
     * Resolve the absolute path to a view file.
     */
    protected static function resolveViewPath(string $view): string
    {
        $view = ltrim($view, "/\\");
        $dir  = self::getViewDir();
        $full = $dir . DIRECTORY_SEPARATOR . $view;

        if (!is_file($full)) {
            throw new ZogException("View file does not exist: {$full}");
        }

        return $full;
    }

    /**
     * Get and validate the view directory.
     */
    protected static function getViewDir(): string
    {
        $dir = self::$viewDir;
        if ($dir === '') {
            throw new ZogException('View directory is not configured.');
        }
        if (!is_dir($dir)) {
            throw new ZogException("View directory does not exist: {$dir}");
        }
        return $dir;
    }

    /**
     * Get (and lazily create) the static directory.
     */
    protected static function getStaticDir(): string
    {
        $dir = self::$staticDir;
        if ($dir === '') {
            throw new ZogException('Static directory is not configured.');
        }
        if (!is_dir($dir)) {
            if (!@mkdir($dir, 0775, true) && !is_dir($dir)) {
                throw new ZogException("Unable to create static directory: {$dir}");
            }
        }
        return $dir;
    }

    /**
     * Get (and lazily create) the compiled templates directory.
     */
    protected static function getCompiledDir(): string
    {
        $dir = self::$compiledDir;
        if ($dir === '') {
            throw new ZogException('Compiled directory is not configured.');
        }
        if (!is_dir($dir)) {
            if (!@mkdir($dir, 0775, true) && !is_dir($dir)) {
                throw new ZogException("Unable to create compiled directory: {$dir}");
            }
        }
        return $dir;
    }

    /**
     * Build the static filename used by hybrid() for a given view + key.
     */
    protected static function getHybridStaticPath(string $view, string|array $key): string
    {
        $baseDir  = self::getStaticDir();
        $viewBase = pathinfo($view, PATHINFO_FILENAME);

        if (is_array($key)) {
            // Normalize array key so that the same logical key always produces the same hash
            $normalized = self::normalizeHybridKeyArray($key);

            $json = json_encode($normalized, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
            if ($json === false) {
                throw new ZogException('Unable to JSON-encode hybrid cache key.');
            }

            // Short hash for filename
            $hash    = substr(sha1($json), 0, 16);
            $safeKey = 'zog-' . $hash;
        } else {
            // String key: keep human-readable slug-like behaviour
            $safeKey = preg_replace('/[^A-Za-z0-9_\-]+/', '-', $key);
            $safeKey = trim($safeKey, '-_');
            if ($safeKey === '') {
                $safeKey = 'default';
            }
        }

        $fileName = $viewBase . '-' . $safeKey . '.php';

        return $baseDir . DIRECTORY_SEPARATOR . $fileName;
    }

    /**
     * Normalize an array key into a stable structure for hashing.
     */
    protected static function normalizeHybridKeyArray(array $key): array
    {
        // Detect if the array is associative (or mixed)
        $isAssoc = array_keys($key) !== range(0, count($key) - 1);
        if ($isAssoc) {
            ksort($key);
        }

        $normalized = [];
        foreach ($key as $k => $v) {
            if (is_array($v)) {
                $normalized[$k] = self::normalizeHybridKeyArray($v);
            } else {
                $normalized[$k] = $v;
            }
        }

        return $normalized;
    }

    /**
     * Compile a view file into a cached PHP file if needed,
     * and return the compiled file path.
     */
    protected static function compileViewIfNeeded(string $viewPath): string
    {
        $compiledDir  = self::getCompiledDir();
        $hash         = sha1($viewPath);
        $compiledPath = $compiledDir . DIRECTORY_SEPARATOR . $hash . '.php';

        $needsCompile = true;

        if (is_file($compiledPath)) {
            $viewMtime     = filemtime($viewPath) ?: 0;
            $compiledMtime = filemtime($compiledPath) ?: 0;

            // Recompile only if view is newer than compiled file
            if ($compiledMtime >= $viewMtime) {
                $needsCompile = false;
            }
        }

        if ($needsCompile) {
            $template = @file_get_contents($viewPath);
            if ($template === false) {
                throw new ZogException("Unable to read view file: {$viewPath}");
            }

            $compiledBody = self::compileTemplate($template);

            $header = "<?php\n"
                . "/* Compiled by Zog from: {$viewPath} at " . date('c') . " */\n"
                . "?>\n";

            $compiledPhp = $header . $compiledBody;

            if (@file_put_contents($compiledPath, $compiledPhp, LOCK_EX) === false) {
                throw new ZogException("Unable to write compiled template: {$compiledPath}");
            }
        }

        return $compiledPath;
    }

    /**
     * Render view and store static version with expiration comment.
     */
    protected static function renderAndStoreHybrid(
        string $view,
        array $data,
        string $staticPath,
        int $ttlSeconds
    ): string {
        $output = self::render($view, $data);

        // Compute expiration date; if ttl <= 0, treat as "never expires"
        if ($ttlSeconds > 0) {
            $expiry        = (new \DateTimeImmutable('now'))
                ->add(new \DateInterval('PT' . $ttlSeconds . 'S'));
            $expiryDateStr = $expiry->format('Y-m-d');
        } else {
            $expiryDateStr = '9999-12-31';
        }

        $comment = '<!-- Automatically generated by zog: [ex:' . $expiryDateStr . '] -->';

        $contentToWrite = $comment . "\n" . $output;

        $dir = dirname($staticPath);
        if (!is_dir($dir)) {
            if (!@mkdir($dir, 0775, true) && !is_dir($dir)) {
                throw new ZogException('Unable to create directory for static file: ' . $dir);
            }
        }

        if (@file_put_contents($staticPath, $contentToWrite, LOCK_EX) === false) {
            throw new ZogException('Failed to write static cache file: ' . $staticPath);
        }

        return $contentToWrite;
    }

    /**
     * Parse expiration date from a static file's autogenerated comment.
     */
    protected static function parseCacheExpiryFromStatic(string $content): ?\DateTimeImmutable
    {
        if (!preg_match(self::CACHE_COMMENT_PATTERN, $content, $matches)) {
            return null;
        }

        $dateStr = $matches[1] ?? '';
        if ($dateStr === '') {
            return null;
        }

        $dt = \DateTimeImmutable::createFromFormat('Y-m-d', $dateStr);
        if ($dt === false) {
            return null;
        }

        return $dt;
    }

    /* ============================================================
     * Template compilation (delegated to Parser)
     * ============================================================
     */

    /**
     * Compile the raw template string into executable PHP+HTML string.
     *
     * All actual parsing is handled by Parser::compile().
     */
    protected static function compileTemplate(string $template): string
    {
        return Parser::compile($template);
    }

    /* ============================================================
     * Template evaluation (require compiled file)
     * ============================================================
     */

    /**
     * Evaluate a compiled template file with the given data (no eval).
     *
     * All keys in $data are extracted as variables.
     * Full array is also available as $zogData inside the template if needed.
     */
    protected static function evaluateCompiledFile(string $compiledPath, array $data): string
    {
        $zogData = $data;

        ob_start();
        try {
            (function () use ($compiledPath, $zogData) {
                if (!empty($zogData)) {
                    extract($zogData, EXTR_SKIP);
                }
                require $compiledPath;
            })();
        } catch (\Throwable $e) {
            ob_end_clean();
            throw new ZogException(
                'Error while rendering template: ' . $e->getMessage(),
                0,
                $e
            );
        }

        return (string) ob_get_clean();
    }
}
