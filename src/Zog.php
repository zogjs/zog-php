<?php
declare(strict_types=1);
namespace Zog;

/**
 * Zog - Lightweight view engine + hybrid static cache (no eval)
 *
 * (نسخهٔ اصلاح‌شده برای حل مشکل @php(...) و پرانتزهای تو در تو)
 */

class ZogException extends \RuntimeException
{
}
class ZogTemplateException extends ZogException
{
}

class Zog
{
    /**
     * Base directory for view files.
     * Relative paths are resolved from the current working directory.
     */
    protected static string $viewDir = 'views';

    /**
     * Base directory for static / cached rendered pages (hybrid).
     */
    protected static string $staticDir = 'static';

    /**
     * Base directory for compiled PHP templates.
     */
    protected static string $compiledDir = 'storage/zog_compiled';

    /**
     * Default hybrid cache TTL in seconds (one week).
     */
    protected static ?int $defaultHybridCacheTtl = 604800;

    /**
     * Whether @php(...) directive is allowed.
     * If set to false, any use of @php will throw an exception.
     */
    protected static bool $allowRawPhpDirective = true;

    /**
     * Placeholder map used to protect directives before DOM parsing.
     * key => ['type' => '@php'|'@json'|'@raw'|'@tojs', 'inner' => string]
     */
    protected static array $directivePlaceholders = [];

    /**
     * Regex to detect the autogenerated cache comment in static files.
     */
    protected const CACHE_COMMENT_PATTERN =
        '/<!--\s*Automatically generated by zog:\s*\[ex:([0-9]{4}-[0-9]{2}-[0-9]{2})\]\s*-->/i';

    // Cache duration constants
    public const CACHE_NONE = 0;
    public const CACHE_A_MINUTE = 60;
    public const CACHE_AN_HOUR = 3600;
    public const CACHE_A_DAY = 86400;
    public const CACHE_A_WEEK = 604800;

    // Alias kept intentionally for compatibility with your sample code
    public const CACH_A_WEEK = 604800;

    /**
     * Configure the base directory for views.
     */
    public static function setDir(string $dir): void
    {
        $dir = rtrim($dir, "/\\");
        if ($dir === '') {
            throw new ZogException('View directory cannot be empty.');
        }
        self::$viewDir = $dir;
    }

    /**
     * Configure the base directory for static / cached files.
     */
    public static function setStaticDir(string $dir): void
    {
        $dir = rtrim($dir, "/\\");
        if ($dir === '') {
            throw new ZogException('Static directory cannot be empty.');
        }
        self::$staticDir = $dir;
    }

    /**
     * Configure the base directory for compiled templates.
     */
    public static function setCompiledDir(string $dir): void
    {
        $dir = rtrim($dir, "/\\");
        if ($dir === '') {
            throw new ZogException('Compiled directory cannot be empty.');
        }
        self::$compiledDir = $dir;
    }

    /**
     * Optionally override the default hybrid cache TTL (in seconds).
     * Pass null to disable default TTL and force explicit TTL in hybrid().
     */
    public static function setDefaultHybridCacheTtl(?int $seconds): void
    {
        if ($seconds !== null && $seconds < 0) {
            throw new ZogException('Default cache TTL cannot be negative.');
        }
        self::$defaultHybridCacheTtl = $seconds;
    }

    /**
     * Enable / disable @php(...) directive.
     */
    public static function allowRawPhpDirective(bool $allow): void
    {
        self::$allowRawPhpDirective = $allow;
    }

    /**
     * Magic handler so you can call Zog::static('file') conveniently.
     *
     * NOTE:
     *   Recommended direct method is Zog::staticFile('path/to/file.ext').
     */
    public static function __callStatic(string $name, array $arguments)
    {
        if ($name === 'static') {
            if (count($arguments) !== 1) {
                throw new ZogException('Zog::static() expects exactly 1 argument (relative static file path).');
            }
            return self::staticFile((string) $arguments[0]);
        }

        throw new ZogException("Undefined static method Zog::{$name}().");
    }

    /**
     * Read a static file from the static directory and return its raw contents.
     * No parsing or processing is performed.
     */
    public static function staticFile(string $relativePath): string
    {
        $relativePath = ltrim($relativePath, "/\\");
        $baseDir = self::getStaticDir();
        $fullPath = $baseDir . DIRECTORY_SEPARATOR . $relativePath;

        $realBase = realpath($baseDir);
        $realFile = realpath($fullPath);

        // Prevent directory traversal
        if ($realBase !== false && $realFile !== false && strpos($realFile, $realBase) !== 0) {
            throw new ZogException('Invalid static file path (path traversal not allowed).');
        }

        if (!is_file($fullPath)) {
            throw new ZogException("Static file not found: {$fullPath}");
        }

        $content = @file_get_contents($fullPath);
        if ($content === false) {
            throw new ZogException("Unable to read static file: {$fullPath}");
        }

        return $content;
    }

    /**
     * Render a view file using Zog template engine.
     *
     * @param string $view  Relative view path (e.g., 'productView.php')
     * @param array  $data  Variables to make available in the view
     *
     * @return string Rendered HTML
     */
    public static function render(string $view, array $data = []): string
    {
        $viewPath = self::resolveViewPath($view);
        $compiledPath = self::compileViewIfNeeded($viewPath);

        return self::evaluateCompiledFile($compiledPath, $data);
    }

    /**
     * Hybrid rendering with optional lazy data factory.
     */
    public static function hybrid(
        string $view,
        string|array $key,
        array|callable|null $dataOrFactory = null,
        ?int $cacheTtl = null
    ) {
        $staticPath = self::getHybridStaticPath($view, $key);

        $hasStatic = is_file($staticPath);
        $content = null;

        if ($hasStatic) {
            $content = @file_get_contents($staticPath);
            if ($content === false) {
                // Treat unreadable file as non-existent
                $hasStatic = false;
                $content = null;
            }
        }

        // -------------------------------------------------
        // 1) Read-only mode: just try to use existing cache.
        // -------------------------------------------------
        if ($dataOrFactory === null) {
            if (!$hasStatic || $content === null) {
                return false;
            }

            $expiry = self::parseCacheExpiryFromStatic($content);
            if ($expiry === null) {
                // No valid expiry => treat as expired
                return false;
            }

            $today = new \DateTimeImmutable('now');
            if ($today->format('Y-m-d') <= $expiry->format('Y-m-d')) {
                // Still valid
                return $content;
            }

            // Expired
            return false;
        }

        // -------------------------------------------------
        // 2) Direct data array: always re-render & overwrite.
        //    This keeps behaviour compatible with older version.
        // -------------------------------------------------
        if (is_array($dataOrFactory)) {
            if ($cacheTtl === null) {
                $cacheTtl = self::$defaultHybridCacheTtl ?? 0;
            }

            return self::renderAndStoreHybrid($view, $dataOrFactory, $staticPath, $cacheTtl);
        }

        // -------------------------------------------------
        // 3) Lazy factory: called ONLY on miss / expired.
        // -------------------------------------------------
        if (is_callable($dataOrFactory)) {
            // If we already have a valid, non-expired static file,
            // return it and DO NOT call the factory.
            if ($hasStatic && $content !== null) {
                $expiry = self::parseCacheExpiryFromStatic($content);
                if ($expiry !== null) {
                    $today = new \DateTimeImmutable('now');
                    if ($today->format('Y-m-d') <= $expiry->format('Y-m-d')) {
                        return $content;
                    }
                }
            }

            // Missing or expired cache => compute data lazily.
            $data = $dataOrFactory();

            if (!is_array($data)) {
                throw new ZogException('Hybrid data factory must return an array.');
            }

            if ($cacheTtl === null) {
                $cacheTtl = self::$defaultHybridCacheTtl ?? 0;
            }

            return self::renderAndStoreHybrid($view, $data, $staticPath, $cacheTtl);
        }

        throw new ZogException(
            'Hybrid third parameter must be either an array, a callable, or null.'
        );
    }



    /**
     * Remove all static files in the configured static directory.
     * This does NOT remove the directory itself.
     */
    public static function clearStatics(): void
    {
        $dir = self::getStaticDir();
        if (!is_dir($dir)) {
            return;
        }

        $iterator = new \DirectoryIterator($dir);
        foreach ($iterator as $fileInfo) {
            if ($fileInfo->isDot()) {
                continue;
            }
            if ($fileInfo->isFile()) {
                @unlink($fileInfo->getPathname());
            }
        }
    }

    /**
     * Remove all compiled template files.
     * This does NOT remove the directory itself.
     */
    public static function clearCompiled(): void
    {
        $dir = self::getCompiledDir();
        if (!is_dir($dir)) {
            return;
        }

        $iterator = new \DirectoryIterator($dir);
        foreach ($iterator as $fileInfo) {
            if ($fileInfo->isDot()) {
                continue;
            }
            if ($fileInfo->isFile()) {
                @unlink($fileInfo->getPathname());
            }
        }
    }

    /* ============================================================
     * Internal helpers: directories & paths
     * ============================================================
     */

    /**
     * Resolve the absolute path to a view file.
     */
    protected static function resolveViewPath(string $view): string
    {
        $view = ltrim($view, "/\\");
        $dir = self::getViewDir();
        $fullDir = $dir . DIRECTORY_SEPARATOR . $view;

        if (!is_file($fullDir)) {
            throw new ZogException("View file does not exist: {$fullDir}");
        }

        return $fullDir;
    }

    /**
     * Get and validate the view directory.
     */
    protected static function getViewDir(): string
    {
        $dir = self::$viewDir;
        if ($dir === '') {
            throw new ZogException('View directory is not configured.');
        }
        if (!is_dir($dir)) {
            throw new ZogException("View directory does not exist: {$dir}");
        }
        return $dir;
    }

    /**
     * Get (and lazily create) the static directory.
     */
    protected static function getStaticDir(): string
    {
        $dir = self::$staticDir;
        if ($dir === '') {
            throw new ZogException('Static directory is not configured.');
        }
        if (!is_dir($dir)) {
            if (!@mkdir($dir, 0775, true) && !is_dir($dir)) {
                throw new ZogException("Unable to create static directory: {$dir}");
            }
        }
        return $dir;
    }

    /**
     * Get (and lazily create) the compiled templates directory.
     */
    protected static function getCompiledDir(): string
    {
        $dir = self::$compiledDir;
        if ($dir === '') {
            throw new ZogException('Compiled directory is not configured.');
        }
        if (!is_dir($dir)) {
            if (!@mkdir($dir, 0775, true) && !is_dir($dir)) {
                throw new ZogException("Unable to create compiled directory: {$dir}");
            }
        }
        return $dir;
    }

    /**
     * Build the static filename used by hybrid() for a given view + key.
     */
    protected static function getHybridStaticPath(string $view, string|array $key): string
    {
        $baseDir = self::getStaticDir();
        $viewBase = pathinfo($view, PATHINFO_FILENAME);

        if (is_array($key)) {
            // Normalize array key so that the same logical key always produces the same hash
            $normalized = self::normalizeHybridKeyArray($key);

            $json = json_encode($normalized, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
            if ($json === false) {
                throw new ZogException('Unable to JSON-encode hybrid cache key.');
            }

            // Short hash for filename
            $hash = substr(sha1($json), 0, 16);
            $safeKey = 'zog-' . $hash;
        } else {
            // string key: keep human-readable slug-like behaviour
            $safeKey = preg_replace('/[^A-Za-z0-9_\-]+/', '-', $key);
            $safeKey = trim($safeKey, '-_');
            if ($safeKey === '') {
                $safeKey = 'default';
            }
        }

        $fileName = $viewBase . '-' . $safeKey . '.php';

        return $baseDir . DIRECTORY_SEPARATOR . $fileName;
    }

    /**
     * Normalize an array key into a stable structure for hashing.
     */
    protected static function normalizeHybridKeyArray(array $key): array
    {
        // Detect if the array is associative (or mixed)
        $isAssoc = array_keys($key) !== range(0, count($key) - 1);
        if ($isAssoc) {
            ksort($key);
        }

        $normalized = [];
        foreach ($key as $k => $v) {
            if (is_array($v)) {
                $normalized[$k] = self::normalizeHybridKeyArray($v);
            } else {
                $normalized[$k] = $v;
            }
        }

        return $normalized;
    }


    /**
     * Compile a view file into a cached PHP file if needed,
     * and return the compiled file path.
     */
    protected static function compileViewIfNeeded(string $viewPath): string
    {
        $compiledDir = self::getCompiledDir();
        $hash = sha1($viewPath);
        $compiledPath = $compiledDir . DIRECTORY_SEPARATOR . $hash . '.php';

        $needsCompile = true;

        if (is_file($compiledPath)) {
            $viewMtime = filemtime($viewPath) ?: 0;
            $compiledMtime = filemtime($compiledPath) ?: 0;

            // Recompile only if view is newer than compiled file
            if ($compiledMtime >= $viewMtime) {
                $needsCompile = false;
            }
        }

        if ($needsCompile) {
            $template = @file_get_contents($viewPath);
            if ($template === false) {
                throw new ZogException("Unable to read view file: {$viewPath}");
            }

            $compiledBody = self::compileTemplate($template);

            $header = "<?php\n"
                . "/* Compiled by Zog from: {$viewPath} at " . date('c') . " */\n"
                . "?>\n";

            $compiledPhp = $header . $compiledBody;

            if (@file_put_contents($compiledPath, $compiledPhp, LOCK_EX) === false) {
                throw new ZogException("Unable to write compiled template: {$compiledPath}");
            }
        }

        return $compiledPath;
    }

    /**
     * Render view and store static version with expiration comment.
     */
    protected static function renderAndStoreHybrid(
        string $view,
        array $data,
        string $staticPath,
        int $ttlSeconds
    ): string {
        $output = self::render($view, $data);

        // Compute expiration date; if ttl <= 0, treat as "never expires"
        if ($ttlSeconds > 0) {
            $expiry = (new \DateTimeImmutable('now'))
                ->add(new \DateInterval('PT' . $ttlSeconds . 'S'));
            $expiryDateStr = $expiry->format('Y-m-d');
        } else {
            $expiryDateStr = '9999-12-31';
        }

        $comment = '<!-- Automatically generated by zog: [ex:' . $expiryDateStr . '] -->';

        $contentToWrite = $comment . "\n" . $output;

        $dir = dirname($staticPath);
        if (!is_dir($dir)) {
            if (!@mkdir($dir, 0775, true) && !is_dir($dir)) {
                throw new ZogException('Unable to create directory for static file: ' . $dir);
            }
        }

        if (@file_put_contents($staticPath, $contentToWrite, LOCK_EX) === false) {
            throw new ZogException('Failed to write static cache file: ' . $staticPath);
        }

        return $contentToWrite;
    }

    /**
     * Parse expiration date from a static file's autogenerated comment.
     */
    protected static function parseCacheExpiryFromStatic(string $content): ?\DateTimeImmutable
    {
        if (!preg_match(self::CACHE_COMMENT_PATTERN, $content, $matches)) {
            return null;
        }

        $dateStr = $matches[1] ?? '';
        if ($dateStr === '') {
            return null;
        }

        $dt = \DateTimeImmutable::createFromFormat('Y-m-d', $dateStr);
        if ($dt === false) {
            return null;
        }

        return $dt;
    }

    /* ============================================================
     * Template compilation (DOM → PHP)
     * ============================================================
     */

    /**
     * Compile the raw template string into executable PHP+HTML string.
     *
     * - Parses HTML using DOMDocument.
     * - Handles:
     *     @{{ expr }}         => escaped echo
     *     @raw(expr)          => raw echo
     *     @php( code )        => raw PHP code
     *     @json(expr) / @tojs(expr) => json_encode(...)
     *     zp-for="a, i of $arr"
     *     zp-if / zp-else-if / zp-else
     */
    protected static function compileTemplate(string $template): string
    {
        // ---------- protect directives so DOM won't turn HTML inside them into elements ----------
        self::$directivePlaceholders = [];
        $counter = 0;

        // helper that stores inner and returns a placeholder token
        $makePlaceholder = function(string $type) use (&$counter) {
            return function(string $inner) use (&$counter, $type) {
                $counter++;
                $key = "__ZOG_" . strtoupper(trim($type, '@')) . "_" . $counter . "__";
                // store raw inner content (unchanged) and the type
                self::$directivePlaceholders[$key] = ['type' => $type, 'inner' => $inner];
                return $key;
            };
        };

        // Protect @php(...)
        $template = self::replaceDirectiveWithBalancedParentheses(
            $template,
            '@php(',
            $makePlaceholder('@php')
        );

        // Protect @json(...) and @tojs(...) (they are equivalent)
        $template = self::replaceDirectiveWithBalancedParentheses(
            $template,
            '@json(',
            $makePlaceholder('@json')
        );
        $template = self::replaceDirectiveWithBalancedParentheses(
            $template,
            '@tojs(',
            $makePlaceholder('@tojs')
        );

        // Protect @raw(...)
        $template = self::replaceDirectiveWithBalancedParentheses(
            $template,
            '@raw(',
            $makePlaceholder('@raw')
        );

        // ---------- now DOM parse safely ----------
        $dom = new \DOMDocument('1.0', 'UTF-8');

        $previous = libxml_use_internal_errors(true);
        $flags = LIBXML_HTML_NOIMPLIED | LIBXML_HTML_NODEFDTD;

        try {
            $dom->loadHTML($template, $flags);
        } finally {
            libxml_clear_errors();
            libxml_use_internal_errors($previous);
        }

        return self::compileNodeList($dom->childNodes);
    }

    /**
     * Recursively compile a DOMNodeList into PHP/HTML string.
     */
    protected static function compileNodeList(\DOMNodeList $nodes): string
    {
        $buffer = '';

        // Convert NodeList to simple array for easier indexing
        $array = [];
        foreach ($nodes as $node) {
            $array[] = $node;
        }

        $len = count($array);
        for ($i = 0; $i < $len; $i++) {
            $node = $array[$i];

            if ($node instanceof \DOMText) {
                $buffer .= self::compileText($node->wholeText);
            } elseif ($node instanceof \DOMElement) {
                // Handle zp-if chains (if / else-if / else)
                if ($node->hasAttribute('zp-if')) {
                    $buffer .= self::compileIfChain($array, $i, $len);
                } elseif ($node->hasAttribute('zp-else-if') || $node->hasAttribute('zp-else')) {
                    // If you reach here, there was no preceding zp-if in this level
                    throw new ZogTemplateException(
                        'Found zp-else-if / zp-else without a preceding zp-if near <' . $node->tagName . '>.'
                    );
                } else {
                    $buffer .= self::compileElement($node);
                }
            } elseif ($node instanceof \DOMComment) {
                $buffer .= '<!--' . $node->nodeValue . '-->';
            } else {
                // Ignore other node types
            }
        }

        return $buffer;
    }

    /**
     * Compile a zp-if / zp-else-if / zp-else chain starting at index $i.
     * Updates $i to the last index of the chain.
     */
    protected static function compileIfChain(array $nodes, int &$i, int $len): string
    {
        $branches = [];

        $first = $nodes[$i];
        if (!($first instanceof \DOMElement)) {
            throw new ZogTemplateException('Internal error: zp-if chain must start with an element node.');
        }

        $expr = trim($first->getAttribute('zp-if'));
        $first->removeAttribute('zp-if');

        $branches[] = [
            'type' => 'if',
            'expr' => $expr,
            'node' => $first,
        ];

        $j = $i + 1;
        while ($j < $len) {
            $sib = $nodes[$j];

            // Skip pure whitespace text nodes between branches
            if ($sib instanceof \DOMText) {
                if (trim($sib->wholeText) === '') {
                    // Just indentation / newlines – ignore for chain detection
                    $j++;
                    continue;
                }
                // Non-empty text breaks the chain
                break;
            }

            // Skip comments between branches
            if ($sib instanceof \DOMComment) {
                $j++;
                continue;
            }

            // Any other non-element node breaks the chain
            if (!($sib instanceof \DOMElement)) {
                break;
            }

            if ($sib->hasAttribute('zp-else-if')) {
                $expr2 = trim($sib->getAttribute('zp-else-if'));
                $sib->removeAttribute('zp-else-if');

                $branches[] = [
                    'type' => 'elseif',
                    'expr' => $expr2,
                    'node' => $sib,
                ];

                $j++;
                continue;
            }

            if ($sib->hasAttribute('zp-else')) {
                $sib->removeAttribute('zp-else');

                $branches[] = [
                    'type' => 'else',
                    'expr' => null,
                    'node' => $sib,
                ];

                $j++;
                break; // else must be last
            }

            // A normal element (without zp-else-if/zp-else) means the chain ended
            break;
        }

        $out = '';
        foreach ($branches as $branch) {
            if ($branch['type'] === 'if') {
                $out .= '<?php if (' . self::ensurePhpExpression($branch['expr']) . '): ?>';
            } elseif ($branch['type'] === 'elseif') {
                $out .= '<?php elseif (' . self::ensurePhpExpression($branch['expr']) . '): ?>';
            } else { // else
                $out .= '<?php else: ?>';
            }

            $out .= self::compileElement($branch['node']);
        }

        $out .= '<?php endif; ?>';

        // Move external loop index to end of chain
        $i = $j - 1;

        return $out;
    }

    /**
     * Compile a single HTML element (plus its children) into PHP/HTML.
     * Handles zp-for at element level.
     */
    protected static function compileElement(\DOMElement $el): string
    {
        $tag = $el->tagName;

        // Attributes except zp-*
        $attrParts = [];
        if ($el->hasAttributes()) {
            foreach ($el->attributes as $attr) {
                $name = $attr->nodeName;
                if (strpos($name, 'zp-') === 0) {
                    // zp-* attributes are consumed by the template engine and
                    // should not appear in the final HTML output.
                    continue;
                }
                $value = $attr->nodeValue ?? '';
                $attrParts[] = $name . '="' . htmlspecialchars($value, ENT_QUOTES | ENT_SUBSTITUTE, 'UTF-8') . '"';
            }
        }

        $attrString = $attrParts ? ' ' . implode(' ', $attrParts) : '';

        // Self-closing tags that should not have closing tag in HTML
        $selfClosingTags = [
            'area',
            'base',
            'br',
            'col',
            'embed',
            'hr',
            'img',
            'input',
            'link',
            'meta',
            'param',
            'source',
            'track',
            'wbr',
        ];
        $isSelfClosing = in_array(strtolower($tag), $selfClosingTags, true);

        $inner = '';
        if (!$isSelfClosing) {
            $inner = self::compileNodeList($el->childNodes);
        }

        $openTag = '<' . $tag . $attrString . ($isSelfClosing ? ' />' : '>');
        $closeTag = $isSelfClosing ? '' : '</' . $tag . '>';

        // Handle zp-for (loop)
        $zpForExpr = null;
        if ($el->hasAttribute('zp-for')) {
            $zpForExpr = trim($el->getAttribute('zp-for'));
            $el->removeAttribute('zp-for');
        }

        if ($zpForExpr !== null && $zpForExpr !== '') {
            [$collectionExpr, $itemVar, $keyVar] = self::parseForExpression($zpForExpr);

            $loopPhp = '<?php foreach (' . $collectionExpr . ' as '
                . ($keyVar ? $keyVar . ' => ' : '')
                . $itemVar . '): ?>';
            $endLoop = '<?php endforeach; ?>';

            return $loopPhp . $openTag . $inner . $closeTag . $endLoop;
        }

        return $openTag . $inner . $closeTag;
    }

    /**
     * Compile plain text node content:
     *   - placeholders for protected directives are restored here
     *   - @{{ expr }}               => escaped echo
     */
    protected static function compileText(string $text): string
    {
        if ($text === '') {
            return '';
        }

        // -- restore directive placeholders (if any) --
        if (strpos($text, '__ZOG_') !== false && !empty(self::$directivePlaceholders)) {
            $text = preg_replace_callback(
                '/__ZOG_[A-Z]+_[0-9]+__/',
                function(array $m) {
                    $key = $m[0];
                    if (!isset(self::$directivePlaceholders[$key])) {
                        return $key; // unknown placeholder, leave as-is
                    }
                    $entry = self::$directivePlaceholders[$key];
                    $type = $entry['type'];
                    $inner = $entry['inner'];

                    // emulate original transforms
                    if ($type === '@php') {
                        $code = trim($inner);
                        if ($code === '') {
                            throw new ZogTemplateException('@php() requires non-empty code.');
                        }
                        return '<?php ' . $code . ' ?>';
                    }

                    if ($type === '@json' || $type === '@tojs') {
                        return self::buildJsonDirective($inner);
                    }

                    if ($type === '@raw') {
                        $expr = trim($inner);
                        if ($expr === '') {
                            throw new ZogTemplateException('@raw() requires a non-empty expression.');
                        }
                        if (preg_match('/^[A-Za-z_][A-Za-z0-9_]*$/', $expr) && $expr[0] !== '$') {
                            $expr = '$' . $expr;
                        }
                        return '<?php echo ' . $expr . '; ?>';
                    }

                    return $key;
                },
                $text
            );
        }

        // Enforce raw PHP directive policy (if still present for some reason)
        if (!self::$allowRawPhpDirective && strpos($text, '@php(') !== false) {
            throw new ZogTemplateException('@php directive is disabled for security reasons.');
        }

        // 5) Handle @{{ expr }}  (escaped echo)
        $text = preg_replace_callback(
            '/@\{\{\s*(.+?)\s*\}\}/s',
            function (array $m): string {
                $expr = trim($m[1]);
                if ($expr === '') {
                    return '';
                }

                // If expr is a bare identifier, auto-prefix with $
                if (preg_match('/^[A-Za-z_][A-Za-z0-9_]*$/', $expr) && $expr[0] !== '$') {
                    $expr = '$' . $expr;
                }

                return '<?php echo htmlspecialchars(' . $expr . ", ENT_QUOTES, 'UTF-8'); ?>";
            },
            $text
        );

        return $text;
    }

    /**
     * Balanced parentheses replacement for directives like:
     *   @php(...)
     *   @json(...)
     *   @tojs(...)
     *   @raw(...)
     *
     * This version is robust: it ignores parentheses inside single/double
     * quoted strings, line/block comments, and attempts to detect heredoc/nowdoc.
     *
     * @param string   $text      Original text
     * @param string   $token     Directive prefix, e.g. "@php(" or "@json("
     * @param callable $transform function(string $inner): string  -> returns replacement
     *
     * @return string
     */
    protected static function replaceDirectiveWithBalancedParentheses(
        string $text,
        string $token,
        callable $transform
    ): string {
        $tokenLen = strlen($token);
        $offset = 0;

        while (true) {
            $start = strpos($text, $token, $offset);
            if ($start === false) {
                break;
            }

            // position of '(' (token expected to include the '(' at the end, e.g. "@php(")
            $openParenPos = $start + $tokenLen - 1;
            $len = strlen($text);

            if ($openParenPos >= $len || $text[$openParenPos] !== '(') {
                throw new ZogTemplateException("Internal error parsing directive {$token}");
            }

            // Scan forward and handle PHP-like strings and comments so parentheses inside them are ignored.
            $depth = 1;
            $i = $openParenPos + 1;

            $inSingleQuote = false;
            $inDoubleQuote = false;
            $inLineComment = false;   // // or #
            $inBlockComment = false;  // /* */
            $inHeredoc = false;
            $heredocLabel = '';

            for (; $i < $len; $i++) {
                $ch = $text[$i];
                $next = ($i + 1 < $len) ? $text[$i + 1] : '';

                // If currently inside a line comment (// or #)
                if ($inLineComment) {
                    if ($ch === "\n" || $ch === "\r") {
                        $inLineComment = false;
                    }
                    continue;
                }

                // If inside block comment /* ... */
                if ($inBlockComment) {
                    if ($ch === '*' && $next === '/') {
                        $inBlockComment = false;
                        $i++; // skip '/'
                    }
                    continue;
                }

                // If inside single-quoted string
                if ($inSingleQuote) {
                    if ($ch === '\\') {
                        // skip escaped char (\' or \\)
                        $i++;
                        continue;
                    }
                    if ($ch === "'") {
                        $inSingleQuote = false;
                    }
                    continue;
                }

                // If inside double-quoted string
                if ($inDoubleQuote) {
                    if ($ch === '\\') {
                        // skip escaped char
                        $i++;
                        continue;
                    }
                    if ($ch === '"') {
                        $inDoubleQuote = false;
                    }
                    continue;
                }

                // If inside heredoc/nowdoc, search for terminator at start of line
                if ($inHeredoc) {
                    // look ahead for "\n" + label   (handle possible "\r\n")
                    $search = "\n" . $heredocLabel;
                    $pos = strpos($text, $search, $i);
                    if ($pos === false) {
                        // not found => unterminated heredoc
                        $i = $len;
                        break;
                    }
                    // after the label there may be optional whitespace and optional ; then newline
                    $afterLabelPos = $pos + strlen($search);
                    $tail = substr($text, $afterLabelPos, 64);
                    if (preg_match('/^[ \t]*(;)?\r?\n/s', $tail, $m)) {
                        // found terminator — set i to the newline after terminator
                        $i = $afterLabelPos + strlen($m[0]) - 1;
                        $inHeredoc = false;
                        continue;
                    } else {
                        // it's not a real terminator — continue searching after pos
                        $i = $pos + 1;
                        continue;
                    }
                }

                // Not inside any string/comment/heredoc — detect entries

                // start of line comment //
                if ($ch === '/' && $next === '/') {
                    $inLineComment = true;
                    $i++; // skip second '/'
                    continue;
                }
                // start of block comment /*
                if ($ch === '/' && $next === '*') {
                    $inBlockComment = true;
                    $i++; // skip '*'
                    continue;
                }
                // shell-style comment #
                if ($ch === '#') {
                    $inLineComment = true;
                    continue;
                }
                // single or double quote start
                if ($ch === "'") {
                    $inSingleQuote = true;
                    continue;
                }
                if ($ch === '"') {
                    $inDoubleQuote = true;
                    continue;
                }

                // heredoc/nowdoc start detection: look for "<<<"
                if ($ch === '<' && $next === '<' && ($i + 2 < $len) && $text[$i + 2] === '<') {
                    // parse label after <<<
                    $j = $i + 3;
                    // skip optional whitespace
                    while ($j < $len && ($text[$j] === ' ' || $text[$j] === "\t")) {
                        $j++;
                    }
                    if ($j >= $len) {
                        // malformed, treat as normal chars
                    } else {
                        $label = '';
                        if ($text[$j] === "'" || $text[$j] === '"') {
                            $quoteChar = $text[$j];
                            $j++;
                            while ($j < $len) {
                                if ($text[$j] === '\\') {
                                    $j += 2;
                                    continue;
                                }
                                if ($text[$j] === $quoteChar) {
                                    $j++;
                                    break;
                                }
                                $label .= $text[$j];
                                $j++;
                            }
                        } else {
                            while ($j < $len && preg_match('/[A-Za-z0-9_]/', $text[$j])) {
                                $label .= $text[$j];
                                $j++;
                            }
                        }

                        // ensure we have a label and there's a newline after the rest of the line
                        if ($label !== '' && preg_match('/\r?\n/', substr($text, $j, 2))) {
                            // found heredoc/nowdoc start
                            $inHeredoc = true;
                            $heredocLabel = $label;
                            $i = $j;
                            continue;
                        }
                    }
                }

                // actual parentheses counting (only when not inside string/comment)
                if ($ch === '(') {
                    $depth++;
                    continue;
                }
                if ($ch === ')') {
                    $depth--;
                    if ($depth === 0) {
                        break; // found matching closing parenthesis
                    }
                    continue;
                }

                // otherwise keep scanning
            }

            if ($depth !== 0 || $i >= $len) {
                throw new ZogTemplateException("Unmatched parentheses in {$token} directive.");
            }

            // Inner contents between the outermost (...)
            $inner = substr($text, $openParenPos + 1, $i - ($openParenPos + 1));

            $replacement = $transform($inner);

            // Replace the whole @xxx( ... ) block
            $text = substr($text, 0, $start)
                . $replacement
                . substr($text, $i + 1);

            // Continue searching after the replacement
            $offset = $start + strlen($replacement);
        }

        return $text;
    }

    /**
     * Build json_encode(...) directive used by @json and @tojs.
     */
    protected static function buildJsonDirective(string $inner): string
    {
        $expr = trim($inner);
        if ($expr === '') {
            throw new ZogTemplateException('@json() / @tojs() requires a non-empty expression.');
        }

        // If expr is a bare identifier (like "products"), auto-prefix with $
        if (preg_match('/^[A-Za-z_][A-Za-z0-9_]*$/', $expr) && $expr[0] !== '$') {
            $expr = '$' . $expr;
        }

        return '<?php echo json_encode(' . $expr
            . ', JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES); ?>';
    }

    /**
     * Parse zp-for expression, e.g.:
     *   "product of $products"
     *   "product, key of $products"
     *
     * Returns array [collectionExpr, $itemVar, $keyVarOrNull].
     */
    protected static function parseForExpression(string $expr): array
    {
        $expr = trim($expr);
        if ($expr === '') {
            throw new ZogTemplateException('Empty zp-for expression.');
        }

        // pattern: item, key of collection   (with optional '$' on item/key)
        if (
            preg_match(
                '/^\$?([A-Za-z_][A-Za-z0-9_]*)\s*,\s*\$?([A-Za-z_][A-Za-z0-9_]*)\s+of\s+(.+)$/',
                $expr,
                $m
            )
        ) {
            $itemVar = self::ensurePhpVariable($m[1]); // خودش $ اضافه می‌کند
            $keyVar = self::ensurePhpVariable($m[2]);
            $collectionExpr = self::ensurePhpExpression($m[3]);

            return [$collectionExpr, $itemVar, $keyVar];
        }

        // pattern: item of collection (with optional '$' on item)
        if (
            preg_match(
                '/^\$?([A-Za-z_][A-Za-z0-9_]*)\s+of\s+(.+)$/',
                $expr,
                $m
            )
        ) {
            $itemVar = self::ensurePhpVariable($m[1]);
            $collectionExpr = self::ensurePhpExpression($m[2]);

            return [$collectionExpr, $itemVar, null];
        }

        throw new ZogTemplateException('Invalid zp-for expression: ' . $expr);
    }


    /**
     * Ensure a variable name is prefixed with '$'.
     */
    protected static function ensurePhpVariable(string $name): string
    {
        $name = trim($name);
        if ($name === '') {
            throw new ZogTemplateException('Empty variable name in zp-for expression.');
        }

        if ($name[0] !== '$') {
            $name = '$' . $name;
        }

        return $name;
    }

    /**
     * Ensure a PHP expression is non-empty.
     * (You are responsible for making it syntactically valid PHP.)
     */
    protected static function ensurePhpExpression(string $expr): string
    {
        $expr = trim($expr);
        if ($expr === '') {
            throw new ZogTemplateException('Empty PHP expression in template.');
        }
        return $expr;
    }

    /* ============================================================
     * Template evaluation (require compiled file)
     * ============================================================
     */

    /**
     * Evaluate a compiled template file with the given data (no eval).
     *
     * All keys in $data are extracted as variables.
     * Full array is also available as $zogData inside the template if needed.
     */
    protected static function evaluateCompiledFile(string $compiledPath, array $data): string
    {
        $zogData = $data;

        ob_start();
        try {
            (function () use ($compiledPath, $zogData) {
                if (!empty($zogData)) {
                    extract($zogData, EXTR_SKIP);
                }
                require $compiledPath;
            })();
        } catch (\Throwable $e) {
            ob_end_clean();
            throw new ZogException(
                'Error while rendering template: ' . $e->getMessage(),
                0,
                $e
            );
        }

        return (string) ob_get_clean();
    }
}
